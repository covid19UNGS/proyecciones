---
title: "Proyecciones y estimaciones de tiempo de duplicación"
author: Grupo covid19UNGS
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: 
  html_document:
    theme: readable
    toc: yes
    toc_depth: 2
editor_options: 
  chunk_output_type: console
bibliography: Epidemics.bib
---

```{r setup, include=FALSE,echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)

needed_packages <- c(
    "tidyverse"
  , "lubridate"
  , "EpiEstim"
  , "incidence"
  , "projections"
  , "epitrix"
  , "distcrete")

lapply(needed_packages, function(x) { if(!require(x,character.only = TRUE)) install.packages(x)} )

require(lubridate)
require(tidyverse)
theme_set(theme_bw())

#csv_fname <- "https://raw.githubusercontent.com/lsaravia/covid19ar/master/coronavirus_ar.csv"
csv_fname <- "Data/coronavirus_ar.csv"


cor <- read_csv(csv_fname) %>% dplyr::select(fecha:TDFdia)
cor <- cor  %>% mutate(fecha=ymd(fecha), dias =as.numeric( fecha - min(fecha))) 
cor <- cor %>% mutate(importadosdia=importados-lag(importados))
cor$importadosdia[1] <- 1
cor <- cor %>% mutate(localesdia=casosdia - importadosdia, CABAdia=ifelse(is.na(CABAdia),0,CABAdia))

# Datos de Casos de Gobierno Nacional 
#
csv_fname <- "Data/covid_19_casos.csv"
cor_nac <- read_csv2(csv_fname)

```


# Estimación de cambios en el número reproductivo efectivo $R_t$

* Datos a partir de los reportes del Ministerio de Salud

El valor de $R_t$ representa el número esperado de casos secundarios que surgen de un caso primario infectado en el momento $t$. Este valor cambia a lo largo de un brote. Si el valor de $R_t$ permanece por debajo de uno, el brote se extinguirá. Sin embargo, cuando $R_t$ es mayor que uno, es probable que se produzca un brote sostenido. El objetivo de las intervenciones de control es típicamente reducir el número de reproducción por debajo de uno [@Thompson2019].

Método de estimación aplicado [@Cori2013; @Thompson2019] permite la inclusión de los casos importados y que se puede estimar el intervalo serial a partir de seguimiento de casos y también incluir variablidad en la distribucion del intervalo serial cuando se asume una distribución gamma discreta.  


* Un parametro importante es el 'Serial interval' (SI). El SI es el tiempo entre el inicio de los síntomas de cada caso de la enfermedad en cuestión, y el inicio de los síntomas en cualquier caso secundario que resulte de la transmisión de los casos primarios. En otras palabras, es el tiempo entre casos en la cadena (de ramificación) de transmisión de la enfermedad. El SI es, de hecho, una distribución estadística de tiempos de intervalo en serie, en lugar de un valor fijo. Esa distribución se puede simular, generalmente utilizando una distribución gamma discreta con una media y desviación estándar dada.

* Se utilizó un 'Serial interval' (SI) estimado por @Li2020 basado en 16 casos es de 7.5 días, con una SD=3.4, pero se permitió que la media del SI variara entre 2.3 y 8.4 usando una distribución normal truncada con una SD de 2.0, y tambien variamos la SD de la SD que variara entre 0.5 y 4.0 

* Luego se estimó el intervalo serial basandose en los datos de @He2020 (77 casos), con una media estimada en su paper de 5.8 días, aunque esta dentro de los parámetros del punto anterior estos datos serían más realistas.

```{r Refectivo, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE,cache=TRUE,cache.extra = tools::md5sum(csv_fname)}
source("R/functions.r")

require(EpiEstim)

incid <- cor %>% dplyr::select(localesdia,importadosdia,fecha) %>% rename(local=localesdia,imported=importadosdia,dates=fecha)
ar_res_parametric_si <- estimate_R(incid, 
                                   method = "uncertain_si", 
                                   config = make_config(list(mean_si = 7.5, std_mean_si = 2, 
                                                             min_mean_si = 1, max_mean_si = 8.4, 
                                                             std_si = 3.4, std_std_si = 1, 
                                                             min_std_si = 0.5, max_std_si = 4, n1 = 1000, n2 = 1000))
)


plot(ar_res_parametric_si, "incid", add_imported_cases=TRUE, ) + labs(title = "Casos por dia Importados y Locales", 
        subtitle = " COVID-19, Argentina, 2020 by @larysar") + theme_bw()

plot(ar_res_parametric_si, "SI")+ theme_bw()

plot(ar_res_parametric_si, "R")+ theme_bw() + labs(title = "Nro Reproductivo Efectivo Basado en 7 días", 
        subtitle = "COVID-19, Argentina, 2020 by @larysar") + theme_bw()

```

## Variación en el intervalo serial 

* Usamos los datos de @He2020 (77 casos) para estimar el intervalo serial (SI media de 5.8) y el $R_t$, hay 
que eliminar el par con ID=9 porque el infector y el infectado suceden el mismo día. Estos datos consisten en la fecha de inicio de los sintomas en casos primarios y la fecha de inicio de sintomas en casos secundarios (originados por los primarios)

```{r RefectivoSI_He, results=FALSE,echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE,cache=TRUE,cache.extra = tools::md5sum(csv_fname)}

pair <- read_tsv("Data/pair_data_He2020.dat") %>% mutate( EL=dmy(EL),ER=dmy(ER),SL=dmy(SL)) %>% mutate(SL=as.integer(SL-EL),SR=as.integer(SL+1),EL=as.integer(0),ER=as.integer(1)) %>% select(-ID) %>% filter(SL-EL>0)

## fixing the random seeds
MCMC_seed <- 1
overall_seed <- 2
mcmc_control <- make_mcmc_control(seed = MCMC_seed, burnin = 1000)
dist <- "G"  # fitting a Gamma distribution for the SI
empirical_si_config <- make_config(list(si_parametric_distr = dist, 
    mcmc_control = mcmc_control, seed = overall_seed, n1 = 50, 
    n2 = 50))
ar_res_empirical_si <- estimate_R(incid, method = "si_from_data", 
    si_data = pair, config = empirical_si_config)

plot(ar_res_empirical_si, "SI")+ theme_bw()

plot(ar_res_empirical_si, "R")+ theme_bw() + labs(title = "Nro Reproductivo Efectivo Basado en 7 días", 
        subtitle = "COVID-19, Argentina, 2020 by @larysar") + theme_bw()

mu <- lapply(ar_res_empirical_si$SI.Moments,median)
sigma <- mu$Std
mu <- mu$Mean
```

La mediana del intervalo serial estimado es **mu =`r mu`** y la desviación **sigma =`r sigma`**, lo cual es diferente de lo reportado en el paper de @He2020 seguramente debido a que se usaron diferentes métodos. De ahora en adelante usaremos el intervalo serial estimado por nosotros.


## Estimaciones usando modelos log-lineales

La fase inicial de un brote, cuando se muestra en un gráfico de semi-log (el eje y con una transformación logarítmica), aparece (algo) lineal. Esto sugiere que podemos modelar el crecimiento y decaimiento epidémico, utilizando un modelo log-lineal simple de la forma:

$$log(y) = rt + b$$

donde $y$ es la incidencia, $r$ es la tasa de crecimiento, $t$ es el número de días desde un punto específico en el tiempo (generalmente el inicio del brote) y $b$ es la ordenada de origen. Se ajustan modelos separados para distintas fases de la curva de epidemia (datos de incidencia).

* Dividimos la curva de incidencia en dos partes, antes y despues del primer pico de incidencia que sucedió despues de la cuarentena (20/03/2020), que resultó el 30/03/2020. Tomamos esta fecha para determinar el $R_0$ antes de la cuarentena 


### Estimamos con los casos locales (no importados) para toda Argentina 

```{r log-linearlocal, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
require(incidence)
require(projections)

cor_incidence_peak <- as.Date("2020-03-30")   # Estimo que alli termina la fase exponencial inicial  


cor_incidence <- cor  %>% dplyr::select(fecha, localesdia) %>% uncount(localesdia)
cor_incidence_obj <- incidence::incidence(cor_incidence$fecha)

#cor_incidence_peak <- find_peak(cor_incidence_obj)

cor_incidence_fit <- incidence::fit(cor_incidence_obj, 
    split = cor_incidence_peak)


# plot the incidence data and the model fit
plot(cor_incidence_obj) %>% add_incidence_fit(cor_incidence_fit) + 
    labs(title = "Incidencia Observada y modelada para casos **locales** COVID-19", 
        subtitle = "Argentina, 2020 by @larysar") + theme_bw()  + geom_vline(xintercept = cor_incidence_peak,col = "red", lty = 2) 


```


* La tasa de crecimiento antes del pico **`r cor_incidence_peak`** fue **`r format(incidence::get_info(cor_incidence_fit, "r")[1],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(cor_incidence_fit, "r.conf")[1,1],digits=2,nsmall=2)` - `r format(incidence::get_info(cor_incidence_fit, "r.conf")[1,2],digits=2,nsmall=2)`)

* La tasa de crecimiento después el pico fue **`r format(incidence::get_info(cor_incidence_fit, "r")[2],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(cor_incidence_fit, "r.conf")[2,2],digits=3,nsmall=2)` - `r format(incidence::get_info(cor_incidence_fit, "r.conf")[2,1],digits=3,nsmall=2)`).

* El tiempo de duplicacion de la primer parte es es **`r format(incidence::get_info(cor_incidence_fit, "doubling")[1],digits=1,nsmall=1)` días** (95% CI `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[1,1],digits=1,nsmall=1)` - `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[1,2],digits=1,nsmall=1)` días)

* El tiempo de duplicación de la segunda parte **`r format(incidence::get_info(cor_incidence_fit, "doubling")[2],digits=1,nsmall=1)` días** (95% CI `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[2,1],digits=1,nsmall=1)` - `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[2,2],digits=1,nsmall=1)` días). 


## Proyecciones para total de casos Argentina

* Esta estimación de proyecciones requiere la estimación del R0 para las distintas fases (creciente y decreciente?), basado en [@Nouvellet2018]. Tomamos los casos locales, en dos fases por el primer pico de incidencia después de la cuarentena.  

* Utiliza datos sobre la incidencia diaria, _el intervalo de serial_ (tiempo entre el inicio de los infectores y los infectados) y el número de reproductivo, que se mantiene constante, para simular trayectorias de epidemia plausibles y proyectar la incidencia futura. Se basa en un proceso de ramificación donde la incidencia diaria sigue un proceso de Poisson determinado por una infecciosidad diaria, calculada como:

$$\lambda_t \sim Pois \left ( \sum_{s=1}^{t-1} y_s w(t-s) \right ) $$ 

donde $w()$ es la función de masa de probabilidad del intervalo serial, y $y_s$ es la incidencia en el tiempo $s$.

```{r proyectR0, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
require(epitrix)
require(distcrete)
# Serial interval estimated by Li2020
#mu <- 7.5 # days
#sigma <- 3.4 # days
#
param <- gamma_mucv2shapescale(mu, sigma / mu)
w <- distcrete("gamma", interval = 1,
                 shape = param$shape,
                 scale = param$scale, w = 0)
growth_R0 <- lm2R0_sample(cor_incidence_fit$before$model, w)

hist(growth_R0, col = "grey", border = "white", main = "Distribution of R0")
summary(growth_R0)

decay_R0 <- lm2R0_sample(cor_incidence_fit$after$model, w)
hist(decay_R0, col = "grey", border = "white", main = "Distribution of R0")
summary(decay_R0)

```

```{r proyect, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

set.seed(1)
pred_fwd_days <- 10
date_range <- 1:(which(get_dates(cor_incidence_obj) == cor_incidence_peak) - pred_fwd_days)
test_pred_growth <- project(cor_incidence_obj[date_range],
                            R = median(growth_R0),
                            si = w,
                            n_days = pred_fwd_days, n_sim = 1000)

# 
#
set.seed(1)
pred_fwd_days <- 10 # 5
date_range <- which(get_dates(cor_incidence_obj) == cor_incidence_peak):(length(get_dates(cor_incidence_obj)) - pred_fwd_days)
test_pred_decay <- project(cor_incidence_obj[date_range],
                            R = median(decay_R0),
                            si = w,
                            n_days = 30, n_sim = 1000)

plot(cor_incidence_obj) %>% add_projections(test_pred_growth, boxplots = FALSE) %>% add_projections(test_pred_decay, boxplots = FALSE) 

```

## Estimación de $R_t$ y tiempo de duplicación para Ciudad de Buenos Aires CABA


* La linea punteada marron vertical es el primer pico de casos local para separar la 1ra fase, de 2da fase. Las lineas rojas es el inicio de la quarentena y las fases del gobierno nacional. También habría que comparar con datos de movilidad. 

* Datos a partir de los reportes del Ministerio de Salud

```{r Rt-log-linearCABA, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE,cache.extra = tools::md5sum(csv_fname)}

dfCABA <- cor %>% dplyr::rename(nue_casosconf_diff=CABAdia)
#dfCABA %>% filter(fecha<"2020-05-15") %>% summarize(totcasos=sum(nue_casosconf_diff))
esProv <- estima_Re_from_df(dfCABA,"CABA",end_date = today())

```


* Datos a partir de "Datos abiertos del ministerio de salud", la diferencia está en la posibilidad de determinar la fecha del inicio de los sintomas y si es caso importado o local. En el set de datos liberado el 15/05/2020 se incluia la información del departamento que en el caso de CABA era la comuna, en el 2do set de datos liberado el 20/05/2020 ya no inlcuye el departamento. 

http://datos.salud.gob.ar/dataset/covid-19-casos-registrados-en-la-republica-argentina/archivo/c9ce10a1-0cac-4ed7-9486-7d437cf2cea1


```{r Rt-log-linearCABA_NAC, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE,cache.extra = tools::md5sum(csv_fname)}

# Datos de Casos de Gobierno Nacional 
#

corConf <- cor_nac %>% filter(provincia_residencia=="CABA",clasificacion_resumen=="Confirmado") %>%
      mutate(fecha=if_else(is.na(fis),fecha_apertura,fis),importado=grepl("VIAJE", antecedente_epidemiologico)) %>%
      mutate(group=if_else(importado,"imported","local"))

cor_incidence_obj <- corConf  %>% select(group,fecha)
cor_incidence_obj <- incidence::incidence(cor_incidence_obj$fecha,groups=cor_incidence_obj$group,
                                          last_date=ymd('2020/05/19'))

esProv <- estima_Re_from_df(cor_incidence_obj,"CABA Locales/Importados/Sintomas")



# cor_incidence <- cor  %>% dplyr::select(fecha, CABAdia) %>% uncount(CABAdia)
# cor_incidence_obj <- incidence::incidence(cor_incidence$fecha, last_date=today())
cor_incidence <- corConf  %>% filter(!importado) %>% select(fecha)
cor_incidence_obj <- incidence::incidence(cor_incidence$fecha, last_date=ymd('2020/05/19'))

#cor_incidence_peak <- find_peak(cor_incidence_obj)
#cor_incidence_peak <- estimate_peak(cor_incidence_obj)
cor_incidence_peak <- as.Date("2020-03-30")   # Estimo que alli termina la fase exponencial inicial  

cor_incidence_fit <- incidence::fit(cor_incidence_obj, 
    split = cor_incidence_peak)


# plot the incidence data and the model fit
plot(cor_incidence_obj) %>% add_incidence_fit(cor_incidence_fit) + 
    labs(title = "Incidencia Observada y modelada para CABA COVID-19", 
        subtitle = "Argentina, 2020 by @larysar") + theme_bw()  + geom_vline(xintercept = cor_incidence_peak,col = "red", lty = 2) 




```


Número total de casos al `r max(cor_nac$ultima_actualizacion)` = `r corConf %>% summarize(totcasos=n())`


* La tasa de crecimiento antes del pico **`r cor_incidence_peak`** fue **`r format(incidence::get_info(cor_incidence_fit, "r")[1],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(cor_incidence_fit, "r.conf")[1,1],digits=2,nsmall=2)` - `r format(incidence::get_info(cor_incidence_fit, "r.conf")[1,2],digits=2,nsmall=2)`)

* La tasa de crecimiento después el pico fue **`r format(incidence::get_info(cor_incidence_fit, "r")[2],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(cor_incidence_fit, "r.conf")[2,2],digits=3,nsmall=2)` - `r format(incidence::get_info(cor_incidence_fit, "r.conf")[2,1],digits=3,nsmall=2)`).

* El tiempo de duplicación de la primer parte es es **`r format(incidence::get_info(cor_incidence_fit,"doubling")[1],digits=1,nsmall=1)` días** (95% CI `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[1,1],digits=1,nsmall=1)` - `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[1,2],digits=1,nsmall=1)` días)

* El tiempo de duplicación de la segunda parte **`r format(incidence::get_info(cor_incidence_fit, "doubling")[2],digits=1,nsmall=1)` días** (95% CI `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[2,1],digits=1,nsmall=1)` - `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[2,2],digits=1,nsmall=1)` días). 


### Proyecciones para CABA

```{r proyectR0CABA, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
require(epitrix)
require(distcrete)
# Serial interval estimated by Li2020
#mu <- 7.5 # days
#sigma <- 3.4 # days
#
param <- gamma_mucv2shapescale(mu, sigma / mu)
w <- distcrete("gamma", interval = 1,
                 shape = param$shape,
                 scale = param$scale, w = 0)
growth_R0 <- lm2R0_sample(cor_incidence_fit$before$model, w)

hist(growth_R0, col = "grey", border = "white", main = "Distribution of R0")
summary(growth_R0)

decay_R0 <- lm2R0_sample(cor_incidence_fit$after$model, w)
hist(decay_R0, col = "grey", border = "white", main = "Distribution of R0")
summary(decay_R0)

```


```{r proyectCABA, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

set.seed(1)
pred_fwd_days <- 10
date_range <- 1:(which(get_dates(cor_incidence_obj) == cor_incidence_peak) - pred_fwd_days)
test_pred_growth <- project(cor_incidence_obj[date_range],
                            R = median(growth_R0),
                            si = w,
                            n_days = pred_fwd_days, n_sim = 1000)

# 
#
set.seed(1)
pred_fwd_days <- 10 # 5
date_range <- which(get_dates(cor_incidence_obj) == cor_incidence_peak):(length(get_dates(cor_incidence_obj)) - pred_fwd_days)
test_pred_decay <- project(cor_incidence_obj[date_range],
                            R = median(decay_R0),
                            si = w,
                            n_days = 30, n_sim = 1000)

plot(cor_incidence_obj) %>% add_projections(test_pred_growth, boxplots = FALSE) %>% add_projections(test_pred_decay, boxplots = FALSE) 

```


## Estimación de $R_t$ y tiempo de duplicación para Tierra Del Fuego

* Primero utilizamos los reportes del Ministerio de Salud. La linea punteada marron vertical es el primer pico de casos local para separar la 1ra fase, de 2da fase. Las lineas rojas es el inicio de la quarentena y las fases del gobierno nacional. Tambien habría que comparar con datos de movilidad. 

```{r Rt-log-linearTDF, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE,cache.extra = tools::md5sum(csv_fname)}

dfCABA <- cor %>% dplyr::rename(nue_casosconf_diff=TDFdia)
esProv <- estima_Re_from_df(dfCABA,"Tierra del Fuego",end_date = today())
```

* Luego los "Datos abiertos del ministerio de salud"

```{r Rt-log-linearTDF_NAC, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE,cache.extra = tools::md5sum(csv_fname)}

# Datos de Casos de Gobierno Nacional 
#

corConf <- cor_nac %>% filter(provincia_residencia=="Tierra del Fuego",clasificacion_resumen=="Confirmado") %>%
      mutate(fecha=if_else(is.na(fis),fecha_apertura,fis),importado=grepl("VIAJE", antecedente_epidemiologico)) %>%
      mutate(group=if_else(importado,"imported","local"))
cor_incidence_obj <- corConf  %>% select(group,fecha)
cor_incidence_obj <- incidence::incidence(cor_incidence_obj$fecha,groups=cor_incidence_obj$group,
                                          last_date=ymd('2020/05/19'))

esProv <- estima_Re_from_df(cor_incidence_obj,"TDF Locales/Importados/Sintomas")

# Tomo casos totales para el ajuste exponencial
#
cor_incidence <- corConf  %>% filter(!importado) %>% select(fecha) #cor  %>% dplyr::select(fecha, TDFdia) %>% uncount(TDFdia)
cor_incidence_obj <- incidence::incidence(cor_incidence$fecha, last_date=ymd('2020/05/19'))
#cor_incidence_loc <- cor_incidence_obj[,"local"] 
cor_incidence_peak <- find_peak(cor_incidence_obj)
# cor_incidence_peak <- as.Date("2020-03-30")   # Estimo que alli termina la fase exponencial inicial  

cor_incidence_fit <- incidence::fit(cor_incidence_obj, 
    split = cor_incidence_peak)


# plot the incidence data and the model fit
plot(cor_incidence_obj) %>% add_incidence_fit(cor_incidence_fit) + 
    labs(title = "Incidencia Observada y modelada para Tierra del Fuego COVID-19", 
        subtitle = "Argentina, 2020 by @larysar") + theme_bw()  + geom_vline(xintercept = cor_incidence_peak,col = "red", lty = 2) 

```

* La tasa de crecimiento antes del pico **`r cor_incidence_peak`** fue **`r format(incidence::get_info(cor_incidence_fit, "r")[1],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(cor_incidence_fit, "r.conf")[1,1],digits=2,nsmall=2)` - `r format(incidence::get_info(cor_incidence_fit, "r.conf")[1,2],digits=2,nsmall=2)`)

* La tasa de crecimiento después el pico fue **`r format(incidence::get_info(cor_incidence_fit, "r")[2],digits=2,nsmall=2)`** (95% CI `r format(incidence::get_info(cor_incidence_fit, "r.conf")[2,2],digits=3,nsmall=2)` - `r format(incidence::get_info(cor_incidence_fit, "r.conf")[2,1],digits=3,nsmall=2)`).

* El tiempo de duplicación de la primer parte es es **`r format(incidence::get_info(cor_incidence_fit,"doubling")[1],digits=1,nsmall=1)` días** (95% CI `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[1,1],digits=1,nsmall=1)` - `r format(incidence::get_info(cor_incidence_fit, "doubling.conf")[1,2],digits=1,nsmall=1)` días)

* El tiempo de disminución a la mitad de la segunda parte **`r format(incidence::get_info(cor_incidence_fit, "halving")[1],digits=1,nsmall=1)` días** (95% CI `r format(incidence::get_info(cor_incidence_fit, "halving.conf")[1],digits=1,nsmall=1)` - `r format(incidence::get_info(cor_incidence_fit, "halving.conf")[2],digits=1,nsmall=1)` días). 

### Proyecciones para Tierra Del Fuego


```{r proyectR0TDF, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}
require(epitrix)
require(distcrete)
# Serial interval estimated by Li2020
#mu <- 7.5 # days
#sigma <- 3.4 # days
#
param <- gamma_mucv2shapescale(mu, sigma / mu)
w <- distcrete("gamma", interval = 1,
                 shape = param$shape,
                 scale = param$scale, w = 0)
growth_R0 <- lm2R0_sample(cor_incidence_fit$before$model, w)

hist(growth_R0, col = "grey", border = "white", main = "Distribution of R0")
summary(growth_R0)

decay_R0 <- lm2R0_sample(cor_incidence_fit$after$model, w)
hist(decay_R0, col = "grey", border = "white", main = "Distribution of R0")
summary(decay_R0)

```


```{r proyectTDF, echo=FALSE, tidy=TRUE, message=FALSE, warning=FALSE}

set.seed(1)
pred_fwd_days <- 5
date_range <- 1:(which(get_dates(cor_incidence_obj) == cor_incidence_peak) - pred_fwd_days)
test_pred_growth <- project(cor_incidence_obj[date_range],
                            R = median(growth_R0),
                            si = w,
                            n_days = pred_fwd_days, n_sim = 1000)

# 
#
set.seed(1)
pred_fwd_days <- 15 # 5
date_range <- which(get_dates(cor_incidence_obj) == cor_incidence_peak):(length(get_dates(cor_incidence_obj)) - pred_fwd_days)
test_pred_decay <- project(cor_incidence_obj[date_range],
                            R = median(decay_R0),
                            si = w,
                            n_days = 30, n_sim = 1000)

plot(cor_incidence_obj) %>% add_projections(test_pred_growth, boxplots = FALSE) %>% add_projections(test_pred_decay, boxplots = FALSE) 

```


## Bibliografía
